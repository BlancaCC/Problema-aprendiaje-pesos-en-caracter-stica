\section{Algoritmo de búsqueda local}  

Si como distancia en el problema anterior tomamos 
\begin{equation}
    d_e(e_1, e_2)
     = 
     \sqrt{
         \sum_i
             w_i \cdot (e^i_1 - e^i_2)^2  
        +
        \sum_j w_j \cdot d_h(e_1^j, e_2^j)
         }
\end{equation}

El vector de pesos $w \in [0,1]^n$ es nuestra incógnita
y deberemos de encontrar el que mejore el clasificador de ponderación 1.

Además puesto que no tenemos variables nominales el resultado será
la distancia final será 

\begin{equation}
  d_e(e_1, e_2)
   = 
   \sqrt{
       \sum_i
           w_i \cdot (e^i_1 - e^i_2)^2  
       }
\end{equation}

\subsection{Componentes del algoritmo de búsqueda local}  

Las métricas a observar de nuestro algoritmo son: 

\begin{itemize}
    \item \textbf{Precisión} o \texttt{tasa-clasificación} Rendimiento promedio para $k=1$ y utilizado \textit{leave one out}.
    \item \textbf{Tasa de reducción}, número de características que se consideran como clasificador. 
    \begin{equation}
        \text{tasa-reducción} 
        = 
        100
        \frac{\text{número de }w_i < 0.1}{\text{número de características}}.
    \end{equation}
    \item \textbf{Función de evaluación} Permite cuantificar el éxito de nuestra selección de pesos de acorde a una  combinación de precisión y simplicidad, su expresión viene dada por 
    \begin{equation}
        F(w) = 
            \alpha \texttt{tasa-clasificación}
            +
            (1 - \alpha) \texttt{tasa-reducción}.
    \end{equation}
    Nótese que $\alpha$ es la ponderación de relevancia que se le da al modelo.
\end{itemize}

\subsection{Búsqueda local del primero mejor}  

El algoritmo que vamos a usar es el conocido como el del \textit{primero mejor} y que radica en esencia de que  cuanto se genera 
una solución que mejora a la actual se aplica el movimiento y se pasa a la siguiente iteración.

Se detiene la búsqueda cuando se haya generado un número máximo de vecinos que no mejora el resultado
o un número máximo de generaciones en las que mejora.

Descripción del algoritmo, necesitamos primero tener una función para general vecinos, de acorde a los requisitos, esta será 
la función \texttt{GeneraVecino($w,\sigma$)} que devolverá un vector 

\textcolor{red}{El vector no puede tomar valores negativos} y además serán menor que 1.
\begin{algorithm}
    \caption{Búsqueda local del primero mejor}
    \hspace*{\algorithmicindent} 
        \textbf{Entrada}:
        \hspace*{\algorithmicindent} 
        \textbf{Salida}:
        Vector de pesos $w$.        
    \begin{algorithmic}[1]
      \Procedure{PrimeroMejor}{$numeroMaximoVecinos$, $evaluacionesMaximas$}
            \Comment{Inicializamos pesos}
          \State $w \gets$ vector aleatorio  
          \State $iteraciones \gets 0$ \Comment{Indica número de generaciones}
        \While{$iteraciones < iteracionesMaximas$ and  $evaluaciones< evaluacionesMaximas $}
        \State $w_{vecino} \gets$ \texttt{GeneraVecino($w,\sigma$)}
        \If{ $F(w_{vecino}) > F(w)$}
          \State $w \gets w_{vecino}$
          \State $iteraciones \gets 0$ 
        \EndIf
        \State $iteraciones \gets iteraciones +1$
        \State $evaluaciones \gets evaluaciones +1$
        \EndWhile
        \State \textbf{return} $w$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

  Para general el vecino hemos usado este algoritmo 

  \begin{algorithm}
    \caption{Genera nuevo vecino}
    \hspace*{\algorithmicindent} 

        \textbf{Entrada}: $w$ vector inicio de dimensión $n$. 
        \hspace*{\algorithmicindent} 
        \textbf{Salida}:
        Vector de pesos $w_{vecino}$.        
    \begin{algorithmic}[1]
      \Procedure{GeneraVecino}{$w$,}   
          \State $z \gets \mathcal{N}(0, \sigma)_{1 \times n}$
          \Comment{vector generado a partir de distribución normal de media 0 y desviación típica $\sigma$}
        \For{$i \in \{1, \ldots, n\}$}
        \Comment{Truncamos entre cero y uno cada componente}
          \State $w_{vecino}[i] \gets \max(0, \min(1, w[i]-z[i]))$
        \EndFor
        \State \textbf{return} $w_{vecino}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}



